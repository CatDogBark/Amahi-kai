class Greyhole
  class GreyholeError < StandardError; end

  CONFIG_PATH = '/etc/greyhole.conf'
  GREYHOLE_REPO_KEY = 'https://www.greyhole.net/releases/deb/greyhole-debsig.asc'
  GREYHOLE_REPO_URL = 'https://www.greyhole.net/releases/deb'
  KEYRING_PATH = '/usr/share/keyrings/greyhole-archive-keyring.gpg'
  SOURCES_PATH = '/etc/apt/sources.list.d/greyhole.list'

  class << self
    def enabled?
      return false unless production?
      installed? && running?
    end

    def installed?
      return true unless production?
      output = `dpkg-query -W -f='${Status}' greyhole 2>/dev/null`.strip
      output == 'install ok installed'
    end

    def running?
      return false unless production?
      system('systemctl is-active --quiet greyhole')
    end

    def status
      return dummy_status unless production?
      {
        installed: installed?,
        running: running?,
        queue: queue_status,
        pool_drives: pool_drives
      }
    end

    def install!
      return true unless production?

      # Add Greyhole apt repository
      unless File.exist?(KEYRING_PATH)
        result = system("curl -s #{GREYHOLE_REPO_KEY} | sudo gpg --dearmor -o #{KEYRING_PATH}")
        raise GreyholeError, 'Failed to add Greyhole signing key' unless result
      end

      unless File.exist?(SOURCES_PATH)
        result = system("echo 'deb [signed-by=#{KEYRING_PATH}] #{GREYHOLE_REPO_URL} stable main' | sudo tee #{SOURCES_PATH} > /dev/null")
        raise GreyholeError, 'Failed to add Greyhole apt source' unless result
      end

      system('sudo apt-get update')

      # Pre-configure: DB and minimal config must exist BEFORE dpkg postinst runs
      system('sudo mysql -u root -e "CREATE DATABASE IF NOT EXISTS greyhole"')
      system("sudo mysql -u root -e \"GRANT ALL PRIVILEGES ON greyhole.* TO 'amahi'@'localhost'; FLUSH PRIVILEGES;\"")

      # Ensure PHP mbstring is available for greyhole
      system('sudo apt-get install -y php-mbstring php-mysql 2>/dev/null')
      system('sudo phpenmod mbstring 2>/dev/null')

      unless File.exist?(CONFIG_PATH)
        system("echo 'db_host = localhost\ndb_user = amahi\ndb_name = greyhole' | sudo tee #{CONFIG_PATH} > /dev/null")
      end

      # Now install â€” postinst script will find DB and config
      result = system('sudo DEBIAN_FRONTEND=noninteractive apt-get install -y -o Dpkg::Options::=--force-confold greyhole')
      raise GreyholeError, 'Failed to install greyhole package' unless result

      # Load schema after install (schema file comes with the package)
      if File.exist?('/usr/share/greyhole/schema-mysql.sql')
        system('sudo mysql -u root greyhole < /usr/share/greyhole/schema-mysql.sql 2>/dev/null')
      end

      # Generate full config and enable service
      configure! if DiskPoolPartition.any?
      system('sudo systemctl enable greyhole.service')
      system('sudo systemctl start greyhole.service')

      true
    end

    def start!
      return true unless production?
      system('sudo systemctl start greyhole')
    end

    def stop!
      return true unless production?
      system('sudo systemctl stop greyhole')
    end

    def restart!
      return true unless production?
      system('sudo systemctl restart greyhole')
    end

    def pool_drives
      return dummy_pool_drives unless production?
      DiskPoolPartition.all.map do |part|
        usage = part.usage
        {
          path: part.path,
          minimum_free: part.minimum_free,
          total: usage[:total],
          free: usage[:free],
          used: usage[:used]
        }
      end
    end

    def queue_status
      return { pending: 0, last_action: nil } unless production?
      begin
        output = `greyhole --status 2>/dev/null`
        parse_queue_status(output)
      rescue
        { pending: 0, last_action: nil }
      end
    end

    def fsck(options = {})
      return true unless production?
      cmd = 'greyhole --fsck'
      cmd += " --dir=#{Shellwords.escape(options[:dir])}" if options[:dir]
      system(cmd)
    end

    def configure!
      return true unless production?
      config = generate_config
      tmp = "/var/hda/tmp/greyhole.conf"
      FileUtils.mkdir_p(File.dirname(tmp))
      File.write(tmp, config)
      system("sudo cp #{Shellwords.escape(tmp)} #{CONFIG_PATH}")
      restart!
    end

    def generate_config
      lines = []
      lines << "# Greyhole configuration - generated by Amahi-kai"
      lines << "# Do not edit manually - changes will be overwritten"
      lines << ""
      lines << "db_host = localhost"
      lines << "db_user = amahi"
      lines << "db_name = greyhole"
      lines << ""

      # Storage pool drives
      DiskPoolPartition.all.each do |part|
        lines << "storage_pool_drive = #{part.path}, min_free: #{part.minimum_free}gb"
      end
      lines << ""

      # Share settings
      Share.where('disk_pool_copies > 0').each do |share|
        copies = share.disk_pool_copies
        copies_str = copies >= 99 ? 'max' : copies.to_s
        lines << "[#{share.name}]"
        lines << "\tnum_copies = #{copies_str}"
        lines << ""
      end

      lines.join("\n")
    end

    private

    def production?
      defined?(Rails) && Rails.env.production?
    end

    def dummy_status
      {
        installed: false,
        running: false,
        queue: { pending: 0, last_action: nil },
        pool_drives: dummy_pool_drives
      }
    end

    def dummy_pool_drives
      DiskPoolPartition.all.map do |part|
        {
          path: part.path,
          minimum_free: part.minimum_free,
          total: 500_000_000_000,
          free: 250_000_000_000,
          used: 250_000_000_000
        }
      end
    end

    def parse_queue_status(output)
      pending = output.scan(/(\d+) pending/).flatten.first.to_i rescue 0
      { pending: pending, last_action: nil }
    end
  end
end
